package acir

import (
	"compress/gzip"
	"encoding/binary"
	"math/big"
	"os"
	hdr "sunpot/acir/header"
	shr "sunpot/acir/shared"

	"fmt"

	"github.com/consensys/gnark/backend/witness"
	"github.com/rs/zerolog/log"
	"github.com/tidwall/btree"
)

// WitnessStacks represent the witnesses generated by `nargo execute`
//
// `nargo execute` constructs a partial witness for every circuit call and
// stores them in a postorder tree traversal order of calling
// meaning that the main circuit is stored in the last index of the map
type WitnessStacks[T shr.ACIRField] map[uint64]btree.Map[shr.Witness, T]

func LoadWitnessStacksFromFile[T shr.ACIRField](filePath string, modulus *big.Int) (WitnessStacks[T], error) {
	file, err := os.Open(filePath)
	if err != nil {
		log.Error().Err(err).Str("file", filePath).Msg("Failed to open witness file")
		return WitnessStacks[T]{}, err
	}
	defer file.Close()

	reader, err := gzip.NewReader(file)
	if err != nil {
		log.Error().Err(err).Msg("Failed to create gzip reader")
		return WitnessStacks[T]{}, err
	}
	defer reader.Close()

	var witnesses WitnessStacks[T]
	var stacksNum uint64
	if err := binary.Read(reader, binary.LittleEndian, &stacksNum); err != nil {
		log.Error().Err(err).Msg("Failed to read number of stacks")
		return WitnessStacks[T]{}, err
	}

	witnesses = make(WitnessStacks[T], stacksNum)
	for i := uint64(0); i < stacksNum; i++ {
		var stackIndex uint32
		if err := binary.Read(reader, binary.LittleEndian, &stackIndex); err != nil {
			return WitnessStacks[T]{}, err
		}

		var witnessMap btree.Map[shr.Witness, T]
		var mapSize uint64
		if err := binary.Read(reader, binary.LittleEndian, &mapSize); err != nil {
			return WitnessStacks[T]{}, err
		}
		for j := uint64(0); j < mapSize; j++ {
			var witness shr.Witness
			if err := binary.Read(reader, binary.LittleEndian, &witness); err != nil {
				return WitnessStacks[T]{}, err
			}

			var value T
			value = shr.MakeNonNil(value)
			if err := value.UnmarshalReader(reader); err != nil {
				return WitnessStacks[T]{}, err
			}

			witnessMap.Set(witness, value)
		}
		witnesses[i] = witnessMap
	}
	return witnesses, nil
}

func (acir *ACIR[T, E]) GetWitness(fileName string, field *big.Int) (witness.Witness, error) {
	witnesses, err := LoadWitnessStacksFromFile[T](fileName, field)
	if err != nil {
		return nil, fmt.Errorf("failed to load witness stack from file %s: %w", fileName, err)
	}

	witness, err := witness.New(field)
	if err != nil {
		return nil, fmt.Errorf("failed to create new witness: %w", err)
	}

	values := make(chan any)

	// Calculate the number of private and public variables
	countPublic := 0
	countPrivate := 0
	for _, param := range acir.ABI.Parameters {
		if param.Visibility == hdr.ACIRParameterVisibilityPublic {
			countPublic++
		}
	}

	for _, itemStack := range witnesses {
		itemStackCount := itemStack.Len()
		countPrivate += itemStackCount
	}

	countPrivate -= countPublic

	go func() {
		// Add the public variables to the beginning of the witness vector.
		// The public variables are accessed by the index in the partial witness
		// of the outermost circuit
		for index, param := range acir.ABI.Parameters {
			if param.Visibility == hdr.ACIRParameterVisibilityPublic {
				outerCircuitStack := witnesses[uint64(len(witnesses)-1)]
				if value, ok := outerCircuitStack.Get(shr.Witness(index)); ok {
					values <- value.ToFrontendVariable()
				} else {
					log.Warn().Msgf("Public parameter %s not found in outermost circuit stack", param.Name)
				}

			}
		}
		for i := 0; i < len(witnesses); i++ {
			partialWitness := witnesses[uint64(i)]
			for it := partialWitness.Iter(); it.Next(); {
				witnessKey := it.Key()
				skipKey := false
				// For the outermost circuit, we skip the witness values
				// that have already been added as part of the public variables
				if i == len(witnesses)-1 {
					for index, param := range acir.ABI.Parameters {
						if witnessKey == shr.Witness(index) && param.Visibility == hdr.ACIRParameterVisibilityPublic {
							skipKey = true
							break
						}
					}
					if acir.WitnessTree != nil && !acir.WitnessTree.Has(witnessKey) {
						skipKey = true
					}
				}
				if skipKey {
					continue
				}
				witnessValue := it.Value()
				values <- witnessValue.ToFrontendVariable()
			}
		}

		close(values)
	}()

	err = witness.Fill(countPublic, countPrivate, values)
	if err != nil {
		return nil, fmt.Errorf("failed to fill witness: %w", err)
	}
	return witness, nil
}
